#!/usr/bin/env php
<?php
use Bunny\Async\Client;
use Bunny\{Channel,Message};
use React\Promise;
use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\{InputInterface,InputOption};
use Symfony\Component\Console\Output\OutputInterface;

    $files = [
        __DIR__ . '/../vendor/autoload.php',
        __DIR__ . '/../autoload.php',
        __DIR__ . '/../../autoload.php',
        __DIR__ . '/../../../autoload.php'
    ];

    foreach ($files as $file) {
        if (file_exists($file)) {
            require $file;
            break;
        }
    }

    $cmd = new class extends Command {
        private $colourLookup = [
            'amq.rabbitmq.log:error' => 'fg=red',
            'amq.rabbitmq.log:warning' => 'fg=yellow',
            'amq.rabbitmq.log:info' => 'fg=green'
        ];

        protected function configure() {
            $this->setName('binky')
                ->setDescription('Introspect RabbitMQ exchanges')
                ->addOption('bind', 'b', InputOption::VALUE_OPTIONAL | InputOption::VALUE_IS_ARRAY, 'an exchange:key to bind to', ['amq.rabbitmq.log:#'])
                ->addOption('host', 'H', InputOption::VALUE_OPTIONAL, 'host to connect to', '127.0.0.1')
                ->addOption('port', 'P', InputOption::VALUE_OPTIONAL, 'Port to bind to', '5672')
                ->addOption('user', 'u', InputOption::VALUE_OPTIONAL, 'username to connect to as', 'guest')
                ->addOption('pass', 'p', InputOption::VALUE_OPTIONAL, 'password to connect to for given user', 'guest')
                ->addOption('vhost', 'vh', InputOption::VALUE_OPTIONAL, 'virtual host to create channel on', '/')
                ->addOption('format', 'f', InputOption::VALUE_NONE, 'format output all pretty like')
            ;
        }

        protected function execute(InputInterface $input, OutputInterface $output) {
            $c = new Client(null, [
                'host'  => $input->getOption('host'),
                'port'  => (int)$input->getOption('port'),
                'user'  => $input->getOption('user'),
                'pass'  => $input->getOption('pass'),
                'vhost' => $input->getOption('vhost'),
            ]);

            $c->connect()->then(function(Client $c) {
                return $c->channel();
            })->then(function (Channel $ch) {
                return Promise\all([
                    $ch,
                    $ch->queueDeclare('', false, false, true, true)
                ]);
            })->then(function($r) use ($input) {
                list($ch, $qr) = $r;

                return Promise\all(array_merge([$ch, $qr], array_map(function($exKey) use ($ch, $qr) {
                    $bindings = new Bindings($exKey);

                    return $ch->queueBind($qr->queue, $bindings->exchange, $bindings->routingKey, false, $bindings->headers);
                }, $input->getOption('bind'))));
            })->then(function($r) use ($input, $output) {
                return $r[0]->consume(function(Message $msg, Channel $ch, Client $c) use ($input, $output) {
                    $content = $msg->content;

                    if ($input->getOption('format') && ('' !== ($contentType = strtolower($msg->getHeader('content-type', ''))))) {
                        if ('application/json' === strtolower($contentType)) {
                            if ("null" !== ($pretty = json_encode(json_decode($content, true), JSON_PRETTY_PRINT))) {
                                $content = $pretty;
                            } else {
                                return $output->writeln("<bg=red>Expected JSON payload, received: {$content}</>");
                            }
                        }
                    }

                    $cKey = "{$msg->exchange}:{$msg->routingKey}";
                    if (array_key_exists($cKey, $this->colourLookup)) {
                        $output->writeln(sprintf("<{$this->colourLookup[$cKey]}>%s</>", $content));
                    } else {
                        $output->writeln("{$msg->exchange}:{$msg->routingKey} > {$content}");
                    }
                }, $r[1]->queue, '', false, true, true);
            });

            $c->run();
        }
    };

class Bindings {
    public $exchange   = '';
    public $routingKey = '';
    public $headers    = [];

    public function __construct($bindingString) {
        $bindings = explode(':', $bindingString);
        $this->exchange = array_shift($bindings);

        switch (count($bindings)) {
            case 0: // assuming topic or fanout exchange
                $this->routingKey = '#';
                break;
            case 1: // assuming topic exchange
                $this->routingKey = $bindings[0];
                break;
            default: // assuming header exchange
                if (strstr($bindingString, '&')) {
                    $this->headers = $this->parseHeader('&', 'all', $bindingString);
                } else if (strstr($bindingString, '|')) {
                    $this->headers = $this->parseHeader('|', 'any', $bindingString);
                } else {
                    list($key, $val) = $bindings;
                    $this->headers[$key] = $val;
                }

                break;
        }
    }

    private function parseHeader($delimiter, $match, $bindingString) {
        return array_reduce(explode($delimiter, substr($bindingString, strlen($this->exchange) + 1)), function($acc, $string) {
            list($key, $val) = explode(':', $string);
            $acc[$key] = $val;

            return $acc;
        }, ['x-match' => $match]);

    }
}

    (new class($cmd) extends Application {
        private $cmd;

        public function __construct(Command $cmd) {
            $this->cmd = $cmd;

            parent::__construct('Binky', 'v0.1');
        }

        protected function getCommandName(InputInterface $input) {
            return $this->cmd->getName();
        }

        protected function getDefaultCommands() {
            $defaults = parent::getDefaultCommands();

            $defaults[] = $this->cmd;

            return $defaults;
        }

        public function getDefinition() {
            $inputDefinition = parent::getDefinition();
            $inputDefinition->setArguments();

            return $inputDefinition;
        }
    })->run();
